/**
 * 当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)
 * 对于每个执行上下文，都有三个重要属性：
 * 1.变量对象 (Variable object，VO)
 * 2.作用域链 (Scope chain)
 * 3.this
 *
 * 这里讨论变量对象
 *
 * */

/**
 * 1.什么是变量对象? 什么是活动对象?
 * 要明白什么是变量对象，首先要搞懂什么是执行上下文，就是上篇所说的这个，这里从另外一个角度来阐述一下，什么是执行上下文
 *
 *  执行环境 定义了 JS 代码的运行环境，这个执行环境包括了 JS 代码有权访问的变量、对象、函数和 this。那具体是怎么实现的呢？
 *  其实，执行环境包含了一个叫做 变量对象 的东西，这个对象保存了环境中定义的所有变量和函数。执行环境可以分为三类：
 *  全局执行环境 ：这是第一行 JS 代码执行时默认的环境，所有的全局代码都在这个环境中执行。
 *  函数执行环境 ： 每个函数都有自己的函数执行环境。每当 JS 引擎发现一个函数调用 （注意是调用，而不是声明），它就会创建一个新的函数执行环境。
 *  Eval : 在 eval 函数中的执行环境。
 *  前面说过，每个执行环境都有一个变量对象，函数执行环境包含的变量对象称之为 活动对象 。
 *
 * 简而言之，就是变量对象就是存储了执行上下文中所有定义的变量，声明的函数，以及对于函数执行上下文的变量对象还包含了函数参数
 *
 * */

/**
 * 1.全局上下文中的变量对象,其实全局上下文中的变量对象说白了就是window对象
 * 2. 函数上下文的变量对象, 它是不可被js程序访问到的，因为变量对象是规范上的或者说是引擎实现上的实现,一般来说,函数上下文中的变量对象是活动对象.
 *
 * */

/**
 * JS代码的执行过程
 * 1.进入执行上下文
 * 2.执行代码
 * */

/**
 * 进入执行上下文要干的事情有哪些?
 * 1.主要是处理代码中的变量和函数声明,并将这些变量的声明和函数的声明挂载到变量对象上.
 *
 * 挂载变量的规则是什么?
 * 1.函数的所有形参 (如果是函数上下文)
 *      由名称和对应值组成的一个变量对象的属性被创建
 *      没有实参，属性值设为 undefined
 * 2.函数声明
 *      由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
 *      如果变量对象已经存在相同名称的属性，则完全替换这个属性
 * 3.变量声明
 *      由名称和对应值（undefined）组成一个变量对象的属性被创建;
 *      如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
 *
 * 总结性的来说,在进入上下文阶段, 对于函数的形参，如果有传入值此时值就是传入的值，对于函数声明，此时的值就是function函数，对于声明的变量,此时的值是undefined
 *
 * 对于不算声明变量也不算声明函数的变量,进入执行上下文阶段是不做任何处理的
 *
 * */



/**
 * 在进入上下文时，会按照如下顺序给变量对象添加初始属性值
 * 形参、函数声明、变量声明(undifined)
 * 在本例中形参的初始属性值是20，在进入上下文中就给赋值了，但是同样是在进入上下文阶段,
 * 函数的名称与形参的名称相同，所以覆盖了形参的初始值（20）
 * 在代码的执行阶段，没有新的值被赋予，所以输入时函数.
 *
 * 补充说明哦，上段文字是去年写的个人认为不是很确切哦，
 * 在进入上下文的时候(执行foo1(20)的时候，)，由于这个形参的存在，在变量对象里首先添加一个属性，这个属性的属性名是a值是20.
 * 但是JS 引擎扫描到function a(){}的时候， 又要给变量对象添加一个名称为a值为function reference的属性,但此时发现在变量对象上已经有了一个名称为a但是值为20的属性，
 * 所以根据上面的规则，替换掉这个属性，此时变量对象上面属性名是a的这个属性的值就是function reference
 *
 *
 * */
function foo1(a){
    console.log(a);
    function a(){}
}
foo1(20)//'function a(){}'

/**
 * 在进入执行上下文阶段，第二个fn2函数覆盖了之前的那个
 * */
function fn1(){
    function fn2(){
        console.log('abcd');
    };
    function fn2(){
        console.log('efgh');
    };
    fn2();
}
fn1();

/**
 * 在进入上下文时， 形参a先被赋值20，但被声明的变量与形参名称相同，所以并不影响a的初始值20.
 * 注意这里和上例不同，上例是，进入上下文阶段，形参a的值是1（最先）,后来被同名函数覆盖.
 * 而在这里，进入上下文的时候，形参a的值是1（最先）,而变量声明a此时是undefined.所以没法覆盖形参
 * 在执行代码的时候，在执行console.log(a)的时候,a 没有被重新赋值过,所以输出是20
 *
 * 上面也是去年写的，不够确切，
 * 在进入上下文的时候(执行foo1(20)的时候，)，由于这个形参的存在，在变量对象里首先添加一个属性，这个属性的属性名是a值是20.
 * 但是JS 引擎扫描到var a = 10;又要给变量对象添加一个名称为a值为undefined的属性,但此时发现在变量对象上已经有了一个名称为a但是值为20的属性
 * 所以根据上面的规则,不干扰已经存在的属性
 * */
function foo2(a){
    console.log(a);
    var a = 10;
}
foo2(20) //'20'


/**
 * 1.当进入函数上下文时，函数上下文的变量对象的属性a的值是10，这是由于形参的作用
 * 2.当执行代码时，所以执行第一个console.log(a);所以它输出的必然是10
 * 3.但是当执行第二个console.log(a);之前,它先去执行了a = 100;,由于这条语句的作用函数上下文的变量对象a属性就发生了变化,变成了100,所以所以它输出的必然是100
 * 4.在函数外面执行console.log(a);它必然输出是10，因为在全局里执行过var a = 10;在进入全局上下文时，全局变量对象就多了一个属性名是a值是10的属性，所以在全局里执行console.log(a);必然输出是10
 * 5.关于a = 100; 要多做两点说明，
 *  第一，在进入函数上下文阶段，由于它既不是变量声明也不是函数声明，所以无法把它挂载到变量对象上。
 *  第二，在执行代码阶段，它会去挂载到一个变量对象上，它首先会究竟找变量对象(本例中就是这个函数变量对象)，
 *      看看这个变量对象上有没有跟它同名的属性，如果有替换掉其值，如果没有，则继续向上寻找，直到找到window对象，在window对象上面挂载上这个值
 * */
var change = function(a){
    console.log(a);//10
    a = 100;
    console.log(a);//100
}

var a = 10;
change(a);
console.log(a);//10


/**
 * 执行a = 100;时，将a挂载到了window对象上
 * */
var change = function(){
    a = 100;
}
change();
console.log(a);//100


/**
 * a把自己挂载到上一层的变量对象上了
 * */
var change = function(){
    var a = 100;
    function fn(){
        a=20;
    }
    fn();
    console.log(a);
}
change();//20

/**
 * 此时这两个输出都是100
 * 进入上下文时，由于a=100里面的a没有var，所以它在进入上下文是不被当成变量对象(A0)的属性,
 * 但是当程序执行到a=100这里的时候，此时它会根据作用域去找变量a，
 * 它没有在函数的作用域里找到a,所以去其父作用域里找(全局作用域)里找,所以此时父作用域里的a被重新赋值
 *
 * */
var change = function(){
    a = 100;
    console.log(a);
}

var a = 10;
change();
console.log(a);



/**
 * 进入函数上下文时，由于形参a的值是20,执行到var a = 10;的时候,发现在VO上已经有了一个名字为a的属性，所以它不干扰.
 * 当执行到function a(){}的时候,发现在VO上已经有了一个名字为a的属性, 覆盖掉它,所以此时VO上的a属性的值是function
 * 进入执行阶段时，第一个console.log(a);就输出了function, 而执行第二个console.log(a);时候，在执行阶段由于var a = 10;的存在a被再次赋值，
 * 所以第二个console.log(a);输出10
 *
 * 在预解析的时候,VO上的a已经是20了而不是undefined,因为此刻a是形参
 * */
function foo3(a){
    console.log(a); // f a(){}
    var a = 10;
    function a(){}
    console.log(a); //10
}
foo3(20);



function a() {
    var aaa = 123;
    function b(){
        console.log(aaa);//undefined
        var aaa = 234;

    };
    b();
};
a();


function a() {
    var aaa = 123;
    function b(){
        console.log(aaa); // 123
        aaa = 234;
    };
    b();
    console.log(aaa);//234
};
a();

function a() {
    var aaa = 123;
    function b(aaa){//aaa现在是function b的形参
        console.log(aaa); // 222
        aaa = 234; //函数上下文的变量对象里有aaa属性，所以只覆盖了函数b上下文的aaa属性
    };
    b(222);
    console.log(aaa);//123
};
a();





/**
 * 在进入fn执行上下文阶段,尽管var a =20;在if语句块中, 但是它仍然被提升到了fn的VO中, 所以输出undefined
 * */
var a = 10;
function fn(){
    console.log(a);//undefined
    if(false){
        var a = 20;
    }
}
fn();

/**
 * 还是输出undefined,这里有另外一个重要的知识点,在if语句块中的函数声明相当于函数变量
 * 也就是说相当于 var a = function(){console.log('abc);},这样的方式变量提升就位undefined
 * */
var a = 10;
function fn(){
    console.log(a);//undefined
    if(false){
        function a(){
            console.log('abc');
        }
    }
}
fn();
/**
 * 报错，一个道理,当函数声明出现在代码块中，javascript 引擎不会将其作为函数声明处理，而是处理成函数表达式
 * */
foo();
if(true){
    function foo(){
        console.log('1111');
    }
}else{
    function foo(){
        console.log('22222');
    }
}

/**
 * 以下的两个输出再次印证了这个道理, 当函数声明出现在代码块中，javascript 引擎不会将其作为函数声明处理，而是处理成函数表达式
 * 所以第一个时undefined,第二个是function
 *
 * 以上是两年前写的，不确切。当function 定义的函数出现在块级作用域时,
 * 在块内部，它作为一个顶一顶额函数会提升到块级作用域顶端, 在块的外部，作为一个var 定义的变量函数 提升到外面
 * */
console.log(fn1);//undefined
{
    console.log(fn1);//function
    function fn1(){
        console.log('abcd');
    }
}
console.log(fn1);//function


/**
 * 报错，这里fn1定义在了小括号里，一个函数表达式(FunctionExpression, 缩写为 FE) 而不是函数声明.函数表达式不会影响VO
 * 跟上例的函数表达式不同，这里的函数表达式并没有分配给var定义的变量，而上例声明在大括号里的函数fn1相当于var fna=function(){}
 * 换句话说下例的这个函数表达式是一个未保存的函数表达式
 * */
(
    function fn1(){
        console.log('abcd');
    }
)
console.log(fn1);//报错

/**
 * 在js中是没有重载这个概念的，第一个fn1没有参数,第二个fn1有参数 此时在进入上下文的时候 第二个fn1 覆盖了第一个fn1的定义
 * */
fn1();
function fn1(){
    console.log('a');
}

function fn1(a){
    console.log('b');
}

fn1();


/**
 *
 * */










