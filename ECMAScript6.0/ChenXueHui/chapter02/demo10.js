/**
 * 堆栈概念与垃圾回收机制
 * */


/**
 * 存取方式
 * 	1、栈	先进后出，后进先出
 * 	2、堆	无序存取，根据引用直接获取
 * 	3、队列	先进先出，后进后出（定时器那里会讲）
 *
*/

/**
 *  内存空间（存储位置）
 *
 * 	1、栈内存（堆栈内存）			2、堆内存
 * 	存储基本数据类型				存储引用数据类型
 * 	按值访问						按引用访问
 * 	存储的值大小固定				存储的值大小不定，可动态调整
 * 	系统自动分配空间				手动分配空间
 * 	系统自动释放空间				手动释放空间
 * 	主要用来执行程序				主要用来存放对象
 * 	空间小，运行效率高			空间大，但是运行效率相对较低
 * 	先进后出，后进先出			无序存储，可根据引用直接获取
 * */

/**
 * 变量生命周期
 * 	1、一个变量与人是一样的都会有生命周期。从定义到不再使用就是一个变量的生命周期
 * 	2、如果变量的生命周期已经到头，那这个变量就会被垃圾回收机制给回收，然后释放它的内存
 * 	3、局部变量的生命周期在函数执行完毕后就会结束（闭包除外）
 * 	4、全局变量的生命周期在页面关闭后结束
 * */

/**
 * * 垃圾回收机制
 * 	1、用来释放内存
 * 	2、当一个数据使用完以后，垃圾回收机制会检测这个数据有没有在其它的地方被引用，或者说在其它的地方有没有再使用。如果没有使用的话就被回收，并释放它占用的内存。如果在其它的地方依然有使用，那就不会被回收
 * 	3、垃圾回收机制是自动的，会定期去检查数据的使用情况
 * 	4、回收策略
 * 		1、标记清除（高版本浏览器）
 * 			1、当变量进入执行环境的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”
 * 			2、垃圾回收机制定期扫描这些标记，如果扫描到标记为“离开环境”，那就会回收它
 * 		2、引用计数（低版本浏览器IE678）
 * 			1、记录每个数据被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值的引用次数减1
 * 			2、当这个数据的引用次数变为0的时候，就会被回收
 * 			3、问题：
 * 				1、当引用次数没有变为0的时候就会造成内存泄漏（IE下）
 * 				2、这种策略没办法记录相互引用的次数
 * */

//标记清除
function fn1(){
    var a=10;	//进入环境
    a++;
    a=null;		//离开环境

    var b=20;	//进入环境
    var c='kaivon';
    b=c;		//离开环境
}
fn1();


function fn2(){
    var a = {};
    var b = {};

    a.name = b;
    b.name = a;
    console.log(a,b);
}
fn2();





